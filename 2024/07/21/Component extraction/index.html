<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、组件开发原则小而美、可拓性强 二、组件逻辑独立性无非两个事情，抽象逻辑和暴露接口，先基于页面内容和功能抽出组件，将页面功能和逻辑抽出，再根据具体功能调节好连接组件内部和连接外部的接口 三、样式独立性(一)module.css是一个CSS文件的命名约定or组织方式，它允许我们写出具有局部作用域的CSS类，这意味着这些类名仅在它们被定义的模块内有效，从而避免了全局命名冲突 1. css modul">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/07/21/Component%20extraction/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、组件开发原则小而美、可拓性强 二、组件逻辑独立性无非两个事情，抽象逻辑和暴露接口，先基于页面内容和功能抽出组件，将页面功能和逻辑抽出，再根据具体功能调节好连接组件内部和连接外部的接口 三、样式独立性(一)module.css是一个CSS文件的命名约定or组织方式，它允许我们写出具有局部作用域的CSS类，这意味着这些类名仅在它们被定义的模块内有效，从而避免了全局命名冲突 1. css modul">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-07-21T08:45:48.539Z">
<meta property="article:modified_time" content="2024-07-21T08:44:03.361Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Component extraction" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/21/Component%20extraction/" class="article-date">
  <time class="dt-published" datetime="2024-07-21T08:45:48.539Z" itemprop="datePublished">2024-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、组件开发原则"><a href="#一、组件开发原则" class="headerlink" title="一、组件开发原则"></a>一、组件开发原则</h3><p>小而美、可拓性强</p>
<h3 id="二、组件逻辑独立性"><a href="#二、组件逻辑独立性" class="headerlink" title="二、组件逻辑独立性"></a>二、组件逻辑独立性</h3><p>无非两个事情，抽象逻辑和暴露接口，先基于页面内容和功能抽出组件，将页面功能和逻辑抽出，再根据具体功能调节好连接组件内部和连接外部的接口</p>
<h3 id="三、样式独立性"><a href="#三、样式独立性" class="headerlink" title="三、样式独立性"></a>三、样式独立性</h3><h4 id="一-module-css"><a href="#一-module-css" class="headerlink" title="(一)module.css"></a>(一)module.css</h4><p>是一个CSS文件的命名约定or组织方式，它允许我们写出具有局部作用域的CSS类，这意味着这些类名仅在它们被定义的模块内有效，从而避免了全局命名冲突</p>
<li><b>1. css modules 解决了什么问题</b>🤗

<p><br><b>全局命名冲突</b><br>因为CSS Modules只关心组件本身，只要保证组件本身命名不冲突，就不会有这样的问题，一个组件被编译之后的类名可能是这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* App.css */</span></span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 编译之后可能是这样的 */</span></span><br><span class="line"><span class="selector-class">.App__text___3lRY_</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名唯一，保证了全局不冲突</p>
<p><br><b>模块化</b><br>可以使用composes来引入自身模块中的样式以及另一个模块的样式（避免重复）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.serif-font</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Georgia, serif;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.display</span> &#123;</span><br><span class="line">  composes: serif-font;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">35px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  composes: dark-red from <span class="string">&quot;./colors.css&quot;</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 引用了相对路径为 &quot;./colors.css&quot; 的类名为的样式 dark-red  */</span></span><br></pre></td></tr></table></figure>

<p><br><b>解决嵌套层次过深的问题</b></p>
<p>因为CSS Modules只关注与组件本身，组件本身基本都可以使用扁平的类名来写，类似于这样的:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.root</span> &#123;</span><br><span class="line">  composes: box from <span class="string">&quot;shared/layout.css&quot;</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: dotted;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  composes: heading from <span class="string">&quot;shared/typography.css&quot;</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">200</span>;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<li><b>2. 使用module.css</b>

<p><br>1.创建css模块文件，比如 styles.module.css 编写css规则，这些规则默认具有局部作用域</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* styles.module.css */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: darkblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>2.导入css模块，导入的css模块会作为一个对象提供所有类名，再使用css类,在组件中使用导入的CSS类,由于CSS模块的类名具有局部作用域，就可以直接使用而不必担心全局冲突</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./styles.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;styles.button&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>3.在 config.js文件中构建配置<br><br>4..在编译时,构建工具将处理css模块并生成最终的css文件，并会将类名替换为唯一的哈希值以避免冲突<br><br>补充：如果你需要在CSS模块中定义全局可用的类，可以在类名前面加上 :global 伪类，如果需要在其他模块中使用全局类，可以将其导出并在其他模块中导入</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:global .globalButton &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<li><b>3. 小结</b>😘

<p><br>modules依靠css模块技术实现样式独立性<br><br>CSS模块中的类名默认只在定义它们的模块内有效，每个模块的作用域是隔离的，意味着即使类名在不同的模块中相同，它们也不会相互冲突<br><br>当CSS模块被构建工具处理时，类名通常会被转换成基于文件名和类名的唯一哈希值,这样即使类名相同，生成的CSS选择器也是唯一的<br><br>在JavaScript或组件文件中导入CSS模块时，不是导入样式本身，而是导入一个包含类名作为属性的对象,这样的话，类名的使用就被限制在导入它们的上下文中</p>
<h4 id="（二）BEM规则"><a href="#（二）BEM规则" class="headerlink" title="（二）BEM规则"></a>（二）BEM规则</h4><li><b>1. 是什么</b>🤨

<p><br>是一种命名规范，旨在简化CSS编写并提高代码的可读性和可维护性，能够最有效解决样式之间同名、继承、优先级等所带来的污染性问题，避免最后因为充斥着各种臃肿，而不敢触及修改遗留的各种未知样式<br><br>该方法将HTML元素划分为三个部分:块<code>block</code>元素<code>element</code>和修饰符<code>modifier</code></p>
<p><br>块（block）是BEM的核心部分，它定义了一个<code>HTML</code>元素的基本结构和行为,块可以使用大写字母命名，例如<code>.Header</code> <code>.Main</code> <code>.Footer</code>等,可以随意的嵌套组合、可复用<br><br>元素（element）是块的一个组成部分，它定义了块中特定内容的样式,元素可以使用小写字母命名，例如<code>.header</code> <code>.main</code> <code>.footer</code>等，依赖block存在（出了block就不能用）<br><br>修饰符（modifier）是针对块或元素的特定状态或行为进行配置的方法,修饰符可以使用中划线（_）或破折号（-）进行命名，例如<code>.header--large</code> <code>.main--centered</code> <code>.footer--light</code>等，一个可选的定义block和element外观的行为<br><br>即：利用<code>-</code>和<code>--</code>将样式命名分区😈，不这么写也行，也没人逼你</p>
<br>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button button--large&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 比如说我写一个按钮 --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="comment">/* 基类-按钮通用样式 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button--large</span> &#123;</span><br><span class="line">  <span class="comment">/* 修饰符-大按钮特定样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>BEM优缺点</b>😈</p>
<li>优点：

<p><br>结构简单明了易于维护，提高可拓展性<br><br>避免对JS依赖：BEM方法使用静态类名，类名在<code>html</code>中是明确定义的，不需要JavaScript来动态添加或移除类，从而减少了对JavaScript的依赖，降低页面的负载和提高性能<br><br>样式隔离–块独立性：每个块都是独立的，拥有自己的样式，不依赖于其他元素或块，使得块可以在上下文中被使用，更不用担心样式冲突<br><br>样式隔离–元素封装：块内的元素只依赖于它们所属的块，而不是其他块或元素。这确保了元素的样式不会泄露到块外部，保持了样式的封装性<br><br></p>
<li>缺点：

<p><br>过度使用会觉得代码有点冗余，特别是类名很长的时候（我就爱写长长的类名bushi🥲（只写三级比较好 呃呃🤗<br><br>在项目中拥有大量的块和元素，很有可能导致命名冲突、可拓展性问题</p>
<h3 id="四、依赖独立性"><a href="#四、依赖独立性" class="headerlink" title="四、依赖独立性"></a>四、依赖独立性</h3><p>这三个字段是JavaScript项目中使用npm管理依赖时package.json文件的组成部分，它们分别代表不同类型的依赖关系：</p>
<h4 id="（一）dependencies"><a href="#（一）dependencies" class="headerlink" title="（一）dependencies"></a>（一）dependencies</h4><p><b>是什么</b>：<code>dependencies</code>（依赖）字段列出了项目运行所必需的依赖，这些依赖在项目部署到生产环境时会被包含进来。<br><br><b>怎么用</b>：当你的项目需要某个库来执行核心功能时，你应该把这个库添加到<code>dependencies</code>中<br>例如，如果你的项目是一个web应用，并且使用了React库，那么React就应该被列为<code>dependencies</code><br><br><b>示例</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;react&quot;</span>: <span class="string">&quot;^16.8.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（二）devDependencies"><a href="#（二）devDependencies" class="headerlink" title="（二）devDependencies"></a>（二）devDependencies</h4><p>是什么：<code>devDependencies</code>(开发依赖)字段包含了只在开发过程中需要的依赖，比如测试框架、构建工具、代码分析工具等,这些依赖在生产环境中不会被安装<br>怎么用：如果你需要某些工具或库来帮助你开发项目（如Webpack、Jest、ESLint等），但这些工具或库在项目部署后不需要，那么应该将它们添加到<code>devDependencies</code><br><br><b>示例</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;jest&quot;</span>: <span class="string">&quot;^24.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^4.29.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="（三）peerDependencies"><a href="#（三）peerDependencies" class="headerlink" title="（三）peerDependencies"></a>（三）peerDependencies</h4><p><b>是什么</b>：<code>peerDependencies</code>（协作依赖）字段用于定义你的库需要与其配合使用的其他库的依赖，但不直接指定版本。这通常用于库的作者，当库需要与其他库协同工作，但不打算控制这些库的版本时<br><br><b>怎么用</b>：当你创建一个库，并希望使用者根据需要安装特定版本的依赖时，你可以在<code>peerDependencies</code>中声明这些依赖。使用者在安装你的库时，需要自己指定这些依赖的版本<br><br><b>示例</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;^3.3.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>区别：</b><br><code>dependencies</code>是项目运行所必需的，会随项目一起部署到生产环境<br><code>devDependencies</code>仅用于开发和测试，不会部署到生产环境<br><code>peerDependencies</code>是一种特殊的依赖声明，用于库与库之间的协同工作，由使用者决定具体版本</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/21/Component%20extraction/" data-id="clyvbscl70000jw4heoe9bp9p" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/05/24/websoket/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/21/Component%20extraction/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/05/24/websoket/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/05/17/TS-node/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/03/17/hooks-usecallback/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/03/02/hook-useeffect/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>